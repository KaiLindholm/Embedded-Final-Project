
Embedded-Final-Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000040  00800100  000004c2  00000556  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800140  00800140  00000596  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000596  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000005c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000118  00000000  00000000  00000608  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000018b4  00000000  00000000  00000720  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c6f  00000000  00000000  00001fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b3f  00000000  00000000  00002c43  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000264  00000000  00000000  00003784  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000615  00000000  00000000  000039e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000b1b  00000000  00000000  00003ffd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c8  00000000  00000000  00004b18  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 ec       	ldi	r30, 0xC2	; 194
  7c:	f4 e0       	ldi	r31, 0x04	; 4
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 34       	cpi	r26, 0x40	; 64
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a0 e4       	ldi	r26, 0x40	; 64
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a1 34       	cpi	r26, 0x41	; 65
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 5a 00 	call	0xb4	; 0xb4 <main>
  9e:	0c 94 5f 02 	jmp	0x4be	; 0x4be <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <init>:
 * @return  int
 */

FILE lcd_str = FDEV_SETUP_STREAM(lcd_putchar, NULL, _FDEV_SETUP_WRITE);
static void init(){
	lcd_init();
  a6:	0e 94 50 01 	call	0x2a0	; 0x2a0 <lcd_init>
	spi_init();
  aa:	0e 94 e7 01 	call	0x3ce	; 0x3ce <spi_init>
	mfrc522_init();
  ae:	0e 94 c1 01 	call	0x382	; 0x382 <mfrc522_init>
  b2:	08 95       	ret

000000b4 <main>:
}
int main (void) {
	uint8_t byte;
	
	
	init();
  b4:	0e 94 53 00 	call	0xa6	; 0xa6 <init>
	fprintf(&lcd_str, "RFID Reader");
  b8:	20 e0       	ldi	r18, 0x00	; 0
  ba:	31 e0       	ldi	r19, 0x01	; 1
  bc:	4b e0       	ldi	r20, 0x0B	; 11
  be:	50 e0       	ldi	r21, 0x00	; 0
  c0:	61 e0       	ldi	r22, 0x01	; 1
  c2:	70 e0       	ldi	r23, 0x00	; 0
  c4:	8e e0       	ldi	r24, 0x0E	; 14
  c6:	91 e0       	ldi	r25, 0x01	; 1
  c8:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <fwrite>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  cc:	2f ef       	ldi	r18, 0xFF	; 255
  ce:	83 ed       	ldi	r24, 0xD3	; 211
  d0:	90 e3       	ldi	r25, 0x30	; 48
  d2:	21 50       	subi	r18, 0x01	; 1
  d4:	80 40       	sbci	r24, 0x00	; 0
  d6:	90 40       	sbci	r25, 0x00	; 0
  d8:	e1 f7       	brne	.-8      	; 0xd2 <main+0x1e>
  da:	00 c0       	rjmp	.+0      	; 0xdc <main+0x28>
  dc:	00 00       	nop
	_delay_ms(1000);
	fprintf(&lcd_str, "");
	byte = mfrc522_read(VersionReg);
  de:	87 e3       	ldi	r24, 0x37	; 55
  e0:	0e 94 ab 01 	call	0x356	; 0x356 <mfrc522_read>
	if(byte == 0x92){
  e4:	82 39       	cpi	r24, 0x92	; 146
  e6:	a9 f4       	brne	.+42     	; 0x112 <main+0x5e>
		fprintf(&lcd_str, "MIFARE RC522");
  e8:	20 e0       	ldi	r18, 0x00	; 0
  ea:	31 e0       	ldi	r19, 0x01	; 1
  ec:	4c e0       	ldi	r20, 0x0C	; 12
  ee:	50 e0       	ldi	r21, 0x00	; 0
  f0:	61 e0       	ldi	r22, 0x01	; 1
  f2:	70 e0       	ldi	r23, 0x00	; 0
  f4:	8a e1       	ldi	r24, 0x1A	; 26
  f6:	91 e0       	ldi	r25, 0x01	; 1
  f8:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <fwrite>
		fprintf(&lcd_str, "Detected");
  fc:	20 e0       	ldi	r18, 0x00	; 0
  fe:	31 e0       	ldi	r19, 0x01	; 1
 100:	48 e0       	ldi	r20, 0x08	; 8
 102:	50 e0       	ldi	r21, 0x00	; 0
 104:	61 e0       	ldi	r22, 0x01	; 1
 106:	70 e0       	ldi	r23, 0x00	; 0
 108:	87 e2       	ldi	r24, 0x27	; 39
 10a:	91 e0       	ldi	r25, 0x01	; 1
 10c:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <fwrite>
 110:	22 c0       	rjmp	.+68     	; 0x156 <main+0xa2>
	} else if(byte == 0x91 || byte == 0x90){
 112:	80 59       	subi	r24, 0x90	; 144
 114:	82 30       	cpi	r24, 0x02	; 2
 116:	a8 f4       	brcc	.+42     	; 0x142 <main+0x8e>
		fprintf(&lcd_str, "MIFARE RC522");
 118:	20 e0       	ldi	r18, 0x00	; 0
 11a:	31 e0       	ldi	r19, 0x01	; 1
 11c:	4c e0       	ldi	r20, 0x0C	; 12
 11e:	50 e0       	ldi	r21, 0x00	; 0
 120:	61 e0       	ldi	r22, 0x01	; 1
 122:	70 e0       	ldi	r23, 0x00	; 0
 124:	8a e1       	ldi	r24, 0x1A	; 26
 126:	91 e0       	ldi	r25, 0x01	; 1
 128:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <fwrite>
		fprintf(&lcd_str, "Detected");
 12c:	20 e0       	ldi	r18, 0x00	; 0
 12e:	31 e0       	ldi	r19, 0x01	; 1
 130:	48 e0       	ldi	r20, 0x08	; 8
 132:	50 e0       	ldi	r21, 0x00	; 0
 134:	61 e0       	ldi	r22, 0x01	; 1
 136:	70 e0       	ldi	r23, 0x00	; 0
 138:	87 e2       	ldi	r24, 0x27	; 39
 13a:	91 e0       	ldi	r25, 0x01	; 1
 13c:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <fwrite>
 140:	0a c0       	rjmp	.+20     	; 0x156 <main+0xa2>
	} else {
		fprintf(&lcd_str, "No reader found");
 142:	20 e0       	ldi	r18, 0x00	; 0
 144:	31 e0       	ldi	r19, 0x01	; 1
 146:	4f e0       	ldi	r20, 0x0F	; 15
 148:	50 e0       	ldi	r21, 0x00	; 0
 14a:	61 e0       	ldi	r22, 0x01	; 1
 14c:	70 e0       	ldi	r23, 0x00	; 0
 14e:	80 e3       	ldi	r24, 0x30	; 48
 150:	91 e0       	ldi	r25, 0x01	; 1
 152:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <fwrite>
 156:	ff cf       	rjmp	.-2      	; 0x156 <main+0xa2>

00000158 <hd44780_outnibble>:
/*
 * Send one nibble out to the LCD controller.
 */
static void hd44780_outnibble(uint8_t n, uint8_t rs)
{
  CLR(PORT, HD44780_RW);
 158:	9b b1       	in	r25, 0x0b	; 11
 15a:	9f 7b       	andi	r25, 0xBF	; 191
 15c:	9b b9       	out	0x0b, r25	; 11
  if (rs)
 15e:	66 23       	and	r22, r22
 160:	21 f0       	breq	.+8      	; 0x16a <hd44780_outnibble+0x12>
    SET(PORT, HD44780_RS);
 162:	9b b1       	in	r25, 0x0b	; 11
 164:	90 68       	ori	r25, 0x80	; 128
 166:	9b b9       	out	0x0b, r25	; 11
 168:	03 c0       	rjmp	.+6      	; 0x170 <hd44780_outnibble+0x18>
  else
    CLR(PORT, HD44780_RS);
 16a:	9b b1       	in	r25, 0x0b	; 11
 16c:	9f 77       	andi	r25, 0x7F	; 127
 16e:	9b b9       	out	0x0b, r25	; 11
  ASSIGN(PORT, HD44780_D4, n);
 170:	2b b1       	in	r18, 0x0b	; 11
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	88 0f       	add	r24, r24
 176:	99 1f       	adc	r25, r25
 178:	92 2f       	mov	r25, r18
 17a:	91 7e       	andi	r25, 0xE1	; 225
 17c:	89 2b       	or	r24, r25
 17e:	8b b9       	out	0x0b, r24	; 11
static inline uint8_t hd44780_pulse_e(bool readback) __attribute__((always_inline));

static inline uint8_t hd44780_pulse_e(bool readback) {
  uint8_t x;

  SET(PORT, HD44780_E);
 180:	8b b1       	in	r24, 0x0b	; 11
 182:	80 62       	ori	r24, 0x20	; 32
 184:	8b b9       	out	0x0b, r24	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 186:	82 e0       	ldi	r24, 0x02	; 2
 188:	8a 95       	dec	r24
 18a:	f1 f7       	brne	.-4      	; 0x188 <hd44780_outnibble+0x30>
 18c:	00 c0       	rjmp	.+0      	; 0x18e <hd44780_outnibble+0x36>
#endif
  if (readback)
    x = READ(PIN, HD44780_D4);
  else
    x = 0;
  CLR(PORT, HD44780_E);
 18e:	8b b1       	in	r24, 0x0b	; 11
 190:	8f 7d       	andi	r24, 0xDF	; 223
 192:	8b b9       	out	0x0b, r24	; 11
 194:	08 95       	ret

00000196 <hd44780_innibble>:
 */
static uint8_t hd44780_innibble(uint8_t rs)
{
  uint8_t x;

  SET(PORT, HD44780_RW);
 196:	9b b1       	in	r25, 0x0b	; 11
 198:	90 64       	ori	r25, 0x40	; 64
 19a:	9b b9       	out	0x0b, r25	; 11
  ASSIGN(DDR, HD44780_D4, 0x00);
 19c:	9a b1       	in	r25, 0x0a	; 10
 19e:	91 7e       	andi	r25, 0xE1	; 225
 1a0:	9a b9       	out	0x0a, r25	; 10
  if (rs)
 1a2:	88 23       	and	r24, r24
 1a4:	21 f0       	breq	.+8      	; 0x1ae <hd44780_innibble+0x18>
    SET(PORT, HD44780_RS);
 1a6:	8b b1       	in	r24, 0x0b	; 11
 1a8:	80 68       	ori	r24, 0x80	; 128
 1aa:	8b b9       	out	0x0b, r24	; 11
 1ac:	03 c0       	rjmp	.+6      	; 0x1b4 <hd44780_innibble+0x1e>
  else
    CLR(PORT, HD44780_RS);
 1ae:	8b b1       	in	r24, 0x0b	; 11
 1b0:	8f 77       	andi	r24, 0x7F	; 127
 1b2:	8b b9       	out	0x0b, r24	; 11
static inline uint8_t hd44780_pulse_e(bool readback) __attribute__((always_inline));

static inline uint8_t hd44780_pulse_e(bool readback) {
  uint8_t x;

  SET(PORT, HD44780_E);
 1b4:	8b b1       	in	r24, 0x0b	; 11
 1b6:	80 62       	ori	r24, 0x20	; 32
 1b8:	8b b9       	out	0x0b, r24	; 11
 1ba:	82 e0       	ldi	r24, 0x02	; 2
 1bc:	8a 95       	dec	r24
 1be:	f1 f7       	brne	.-4      	; 0x1bc <hd44780_innibble+0x26>
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <hd44780_innibble+0x2c>
  __asm__ volatile("nop");
#    endif /* F_CPU > 2000000UL */
#  endif /* F_CPU > 1000000UL */
#endif
  if (readback)
    x = READ(PIN, HD44780_D4);
 1c2:	89 b1       	in	r24, 0x09	; 9
 1c4:	8e 71       	andi	r24, 0x1E	; 30
 1c6:	90 e0       	ldi	r25, 0x00	; 0
 1c8:	95 95       	asr	r25
 1ca:	87 95       	ror	r24
  else
    x = 0;
  CLR(PORT, HD44780_E);
 1cc:	9b b1       	in	r25, 0x0b	; 11
 1ce:	9f 7d       	andi	r25, 0xDF	; 223
 1d0:	9b b9       	out	0x0b, r25	; 11
  if (rs)
    SET(PORT, HD44780_RS);
  else
    CLR(PORT, HD44780_RS);
  x = hd44780_pulse_e(true);
  ASSIGN(DDR, HD44780_D4, 0x0F);
 1d2:	9a b1       	in	r25, 0x0a	; 10
 1d4:	9e 61       	ori	r25, 0x1E	; 30
 1d6:	9a b9       	out	0x0a, r25	; 10
  CLR(PORT, HD44780_RW);
 1d8:	9b b1       	in	r25, 0x0b	; 11
 1da:	9f 7b       	andi	r25, 0xBF	; 191
 1dc:	9b b9       	out	0x0b, r25	; 11

  return x;
}
 1de:	08 95       	ret

000001e0 <hd44780_outbyte>:
/*
 * Send one byte to the LCD controller.  As we are in 4-bit mode, we
 * have to send two nibbles.
 */
void hd44780_outbyte(uint8_t b, uint8_t rs)
{
 1e0:	cf 93       	push	r28
 1e2:	df 93       	push	r29
 1e4:	c8 2f       	mov	r28, r24
 1e6:	d6 2f       	mov	r29, r22
  hd44780_outnibble(b >> 4, rs);
 1e8:	82 95       	swap	r24
 1ea:	8f 70       	andi	r24, 0x0F	; 15
 1ec:	0e 94 ac 00 	call	0x158	; 0x158 <hd44780_outnibble>
  hd44780_outnibble(b & 0xf, rs);
 1f0:	6d 2f       	mov	r22, r29
 1f2:	8c 2f       	mov	r24, r28
 1f4:	8f 70       	andi	r24, 0x0F	; 15
 1f6:	0e 94 ac 00 	call	0x158	; 0x158 <hd44780_outnibble>
}
 1fa:	df 91       	pop	r29
 1fc:	cf 91       	pop	r28
 1fe:	08 95       	ret

00000200 <hd44780_inbyte>:

/*
 * Read one byte (i.e. two nibbles) from the LCD controller.
 */
uint8_t hd44780_inbyte(uint8_t rs)
{
 200:	cf 93       	push	r28
 202:	df 93       	push	r29
 204:	c8 2f       	mov	r28, r24
  uint8_t x;

  x = hd44780_innibble(rs) << 4;
 206:	0e 94 cb 00 	call	0x196	; 0x196 <hd44780_innibble>
 20a:	d8 2f       	mov	r29, r24
 20c:	d2 95       	swap	r29
 20e:	d0 7f       	andi	r29, 0xF0	; 240
  x |= hd44780_innibble(rs);
 210:	8c 2f       	mov	r24, r28
 212:	0e 94 cb 00 	call	0x196	; 0x196 <hd44780_innibble>

  return x;
}
 216:	8d 2b       	or	r24, r29
 218:	df 91       	pop	r29
 21a:	cf 91       	pop	r28
 21c:	08 95       	ret

0000021e <hd44780_wait_ready>:
 * Wait until the busy flag is cleared.
 */
void hd44780_wait_ready(bool longwait)
{
#if USE_BUSY_BIT
  while (hd44780_incmd() & HD44780_BUSYFLAG) ;
 21e:	80 e0       	ldi	r24, 0x00	; 0
 220:	0e 94 00 01 	call	0x200	; 0x200 <hd44780_inbyte>
 224:	88 23       	and	r24, r24
 226:	dc f3       	brlt	.-10     	; 0x21e <hd44780_wait_ready>
  if (longwait)
    _delay_ms(1.52);
  else
    _delay_us(37);
#endif
}
 228:	08 95       	ret

0000022a <hd44780_init>:
{
  //SET(DDR, HD44780_RS);
  //SET(DDR, HD44780_RW);
  //SET(DDR, HD44780_E);
  //ASSIGN(DDR, HD44780_D4, 0x0F);
  DDRD |= 0b11111110;
 22a:	8a b1       	in	r24, 0x0a	; 10
 22c:	8e 6f       	ori	r24, 0xFE	; 254
 22e:	8a b9       	out	0x0a, r24	; 10
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 230:	8f e5       	ldi	r24, 0x5F	; 95
 232:	9a ee       	ldi	r25, 0xEA	; 234
 234:	01 97       	sbiw	r24, 0x01	; 1
 236:	f1 f7       	brne	.-4      	; 0x234 <hd44780_init+0xa>
 238:	00 c0       	rjmp	.+0      	; 0x23a <hd44780_init+0x10>
 23a:	00 00       	nop

  _delay_ms(15);		/* 40 ms needed for Vcc = 2.7 V */
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
 23c:	60 e0       	ldi	r22, 0x00	; 0
 23e:	83 e0       	ldi	r24, 0x03	; 3
 240:	0e 94 ac 00 	call	0x158	; 0x158 <hd44780_outnibble>
 244:	8f e0       	ldi	r24, 0x0F	; 15
 246:	90 e4       	ldi	r25, 0x40	; 64
 248:	01 97       	sbiw	r24, 0x01	; 1
 24a:	f1 f7       	brne	.-4      	; 0x248 <hd44780_init+0x1e>
 24c:	00 c0       	rjmp	.+0      	; 0x24e <hd44780_init+0x24>
 24e:	00 00       	nop
  _delay_ms(4.1);
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
 250:	60 e0       	ldi	r22, 0x00	; 0
 252:	83 e0       	ldi	r24, 0x03	; 3
 254:	0e 94 ac 00 	call	0x158	; 0x158 <hd44780_outnibble>
 258:	8f e8       	ldi	r24, 0x8F	; 143
 25a:	91 e0       	ldi	r25, 0x01	; 1
 25c:	01 97       	sbiw	r24, 0x01	; 1
 25e:	f1 f7       	brne	.-4      	; 0x25c <hd44780_init+0x32>
 260:	00 c0       	rjmp	.+0      	; 0x262 <hd44780_init+0x38>
 262:	00 00       	nop
  _delay_ms(0.1);
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
 264:	60 e0       	ldi	r22, 0x00	; 0
 266:	83 e0       	ldi	r24, 0x03	; 3
 268:	0e 94 ac 00 	call	0x158	; 0x158 <hd44780_outnibble>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 26c:	95 ec       	ldi	r25, 0xC5	; 197
 26e:	9a 95       	dec	r25
 270:	f1 f7       	brne	.-4      	; 0x26e <hd44780_init+0x44>
 272:	00 00       	nop
  _delay_us(37);

  hd44780_outnibble(HD44780_FNSET(0, 1, 0) >> 4, 0);
 274:	60 e0       	ldi	r22, 0x00	; 0
 276:	82 e0       	ldi	r24, 0x02	; 2
 278:	0e 94 ac 00 	call	0x158	; 0x158 <hd44780_outnibble>
  hd44780_wait_ready(false);
 27c:	80 e0       	ldi	r24, 0x00	; 0
 27e:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
  hd44780_outcmd(HD44780_FNSET(0, 1, 0));
 282:	60 e0       	ldi	r22, 0x00	; 0
 284:	88 e2       	ldi	r24, 0x28	; 40
 286:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
  hd44780_wait_ready(false);
 28a:	80 e0       	ldi	r24, 0x00	; 0
 28c:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
  hd44780_outcmd(HD44780_DISPCTL(0, 0, 0));
 290:	60 e0       	ldi	r22, 0x00	; 0
 292:	88 e0       	ldi	r24, 0x08	; 8
 294:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
  hd44780_wait_ready(false);
 298:	80 e0       	ldi	r24, 0x00	; 0
 29a:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
 29e:	08 95       	ret

000002a0 <lcd_init>:
 * Setup the LCD controller.  First, call the hardware initialization
 * function, then adjust the display attributes we want.
 */
void lcd_init(void) {

  hd44780_init();
 2a0:	0e 94 15 01 	call	0x22a	; 0x22a <hd44780_init>

  /*
   * Clear the display.
   */
  hd44780_outcmd(HD44780_CLR);
 2a4:	60 e0       	ldi	r22, 0x00	; 0
 2a6:	81 e0       	ldi	r24, 0x01	; 1
 2a8:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
  hd44780_wait_ready(true);
 2ac:	81 e0       	ldi	r24, 0x01	; 1
 2ae:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>

  /*
   * Entry mode: auto-increment address counter, no display shift in
   * effect.
   */
  hd44780_outcmd(HD44780_ENTMODE(1, 0));
 2b2:	60 e0       	ldi	r22, 0x00	; 0
 2b4:	86 e0       	ldi	r24, 0x06	; 6
 2b6:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
  hd44780_wait_ready(false);
 2ba:	80 e0       	ldi	r24, 0x00	; 0
 2bc:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>

  /*
   * Enable display, activate non-blinking cursor.
   */
  hd44780_outcmd(HD44780_DISPCTL(1, 1, 0));
 2c0:	60 e0       	ldi	r22, 0x00	; 0
 2c2:	8e e0       	ldi	r24, 0x0E	; 14
 2c4:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
  hd44780_wait_ready(false);
 2c8:	80 e0       	ldi	r24, 0x00	; 0
 2ca:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
 2ce:	08 95       	ret

000002d0 <lcd_putchar>:

/*
 * Send character c to the LCD display.  After a '\n' has been seen,
 * the next character will first clear the display.
 */
int lcd_putchar(char c, FILE *unused){
 2d0:	cf 93       	push	r28
 2d2:	c8 2f       	mov	r28, r24
  static bool nl_seen;

  if (nl_seen && c != '\n')
 2d4:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <__data_end>
 2d8:	88 23       	and	r24, r24
 2da:	c9 f0       	breq	.+50     	; 0x30e <lcd_putchar+0x3e>
 2dc:	ca 30       	cpi	r28, 0x0A	; 10
 2de:	b9 f0       	breq	.+46     	; 0x30e <lcd_putchar+0x3e>
    {
      /*
       * First character after newline, clear display and home cursor.
       */
      hd44780_wait_ready(false);
 2e0:	80 e0       	ldi	r24, 0x00	; 0
 2e2:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
      hd44780_outcmd(HD44780_CLR);
 2e6:	60 e0       	ldi	r22, 0x00	; 0
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
      hd44780_wait_ready(false);
 2ee:	80 e0       	ldi	r24, 0x00	; 0
 2f0:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
      hd44780_outcmd(HD44780_HOME);
 2f4:	60 e0       	ldi	r22, 0x00	; 0
 2f6:	82 e0       	ldi	r24, 0x02	; 2
 2f8:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
      hd44780_wait_ready(true);
 2fc:	81 e0       	ldi	r24, 0x01	; 1
 2fe:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
      hd44780_outcmd(HD44780_DDADDR(0));
 302:	60 e0       	ldi	r22, 0x00	; 0
 304:	80 e8       	ldi	r24, 0x80	; 128
 306:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>

      nl_seen = false;
 30a:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <__data_end>
    }
  if (c == '\n')
 30e:	ca 30       	cpi	r28, 0x0A	; 10
 310:	21 f4       	brne	.+8      	; 0x31a <lcd_putchar+0x4a>
    {
      nl_seen = true;
 312:	81 e0       	ldi	r24, 0x01	; 1
 314:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end>
 318:	07 c0       	rjmp	.+14     	; 0x328 <lcd_putchar+0x58>
    }
  else
    {
      hd44780_wait_ready(false);
 31a:	80 e0       	ldi	r24, 0x00	; 0
 31c:	0e 94 0f 01 	call	0x21e	; 0x21e <hd44780_wait_ready>
      hd44780_outdata(c);
 320:	61 e0       	ldi	r22, 0x01	; 1
 322:	8c 2f       	mov	r24, r28
 324:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <hd44780_outbyte>
    }

  return 0;
 328:	80 e0       	ldi	r24, 0x00	; 0
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	cf 91       	pop	r28
 32e:	08 95       	ret

00000330 <mfrc522_write>:
		mfrc522_write(TxControlReg,byte|0x03);
	}
}

void mfrc522_write(uint8_t reg, uint8_t data)
{
 330:	cf 93       	push	r28
 332:	c6 2f       	mov	r28, r22
	ENABLE_CHIP();
 334:	95 b1       	in	r25, 0x05	; 5
 336:	9b 7f       	andi	r25, 0xFB	; 251
 338:	95 b9       	out	0x05, r25	; 5
	spi_transmit((reg<<1)&0x7E);
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	88 0f       	add	r24, r24
 33e:	99 1f       	adc	r25, r25
 340:	8e 77       	andi	r24, 0x7E	; 126
 342:	0e 94 ee 01 	call	0x3dc	; 0x3dc <spi_transmit>
	spi_transmit(data);
 346:	8c 2f       	mov	r24, r28
 348:	0e 94 ee 01 	call	0x3dc	; 0x3dc <spi_transmit>
	DISABLE_CHIP();
 34c:	85 b1       	in	r24, 0x05	; 5
 34e:	84 60       	ori	r24, 0x04	; 4
 350:	85 b9       	out	0x05, r24	; 5
}
 352:	cf 91       	pop	r28
 354:	08 95       	ret

00000356 <mfrc522_read>:

uint8_t mfrc522_read(uint8_t reg)
{
	uint8_t data;	
	ENABLE_CHIP();
 356:	95 b1       	in	r25, 0x05	; 5
 358:	9b 7f       	andi	r25, 0xFB	; 251
 35a:	95 b9       	out	0x05, r25	; 5
	spi_transmit(((reg<<1)&0x7E)|0x80);
 35c:	90 e0       	ldi	r25, 0x00	; 0
 35e:	88 0f       	add	r24, r24
 360:	99 1f       	adc	r25, r25
 362:	8e 77       	andi	r24, 0x7E	; 126
 364:	80 68       	ori	r24, 0x80	; 128
 366:	0e 94 ee 01 	call	0x3dc	; 0x3dc <spi_transmit>
	data = spi_transmit(0x00);
 36a:	80 e0       	ldi	r24, 0x00	; 0
 36c:	0e 94 ee 01 	call	0x3dc	; 0x3dc <spi_transmit>
	DISABLE_CHIP();
 370:	95 b1       	in	r25, 0x05	; 5
 372:	94 60       	ori	r25, 0x04	; 4
 374:	95 b9       	out	0x05, r25	; 5
	return data;
}
 376:	08 95       	ret

00000378 <mfrc522_reset>:

void mfrc522_reset()
{
	mfrc522_write(CommandReg,SoftReset_CMD);
 378:	6f e0       	ldi	r22, 0x0F	; 15
 37a:	81 e0       	ldi	r24, 0x01	; 1
 37c:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
 380:	08 95       	ret

00000382 <mfrc522_init>:
#include "spi.h"

void mfrc522_init()
{
	uint8_t byte;
	mfrc522_reset();
 382:	0e 94 bc 01 	call	0x378	; 0x378 <mfrc522_reset>
	
	mfrc522_write(TModeReg, 0x8D);
 386:	6d e8       	ldi	r22, 0x8D	; 141
 388:	8a e2       	ldi	r24, 0x2A	; 42
 38a:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
    mfrc522_write(TPrescalerReg, 0x3E);
 38e:	6e e3       	ldi	r22, 0x3E	; 62
 390:	8b e2       	ldi	r24, 0x2B	; 43
 392:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
    mfrc522_write(TReloadReg_1, 30);   
 396:	6e e1       	ldi	r22, 0x1E	; 30
 398:	8c e2       	ldi	r24, 0x2C	; 44
 39a:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
    mfrc522_write(TReloadReg_2, 0);	
 39e:	60 e0       	ldi	r22, 0x00	; 0
 3a0:	8d e2       	ldi	r24, 0x2D	; 45
 3a2:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
	mfrc522_write(TxASKReg, 0x40);	
 3a6:	60 e4       	ldi	r22, 0x40	; 64
 3a8:	85 e1       	ldi	r24, 0x15	; 21
 3aa:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
	mfrc522_write(ModeReg, 0x3D);
 3ae:	6d e3       	ldi	r22, 0x3D	; 61
 3b0:	81 e1       	ldi	r24, 0x11	; 17
 3b2:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
	
	byte = mfrc522_read(TxControlReg);
 3b6:	84 e1       	ldi	r24, 0x14	; 20
 3b8:	0e 94 ab 01 	call	0x356	; 0x356 <mfrc522_read>
	if(!(byte&0x03))
 3bc:	98 2f       	mov	r25, r24
 3be:	93 70       	andi	r25, 0x03	; 3
 3c0:	29 f4       	brne	.+10     	; 0x3cc <mfrc522_init+0x4a>
	{
		mfrc522_write(TxControlReg,byte|0x03);
 3c2:	68 2f       	mov	r22, r24
 3c4:	63 60       	ori	r22, 0x03	; 3
 3c6:	84 e1       	ldi	r24, 0x14	; 20
 3c8:	0e 94 98 01 	call	0x330	; 0x330 <mfrc522_write>
 3cc:	08 95       	ret

000003ce <spi_init>:
#include "spi.h"

#if SPI_CONFIG_AS_MASTER
void spi_init()
{
	SPI_DDR |= (1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_SS);
 3ce:	84 b1       	in	r24, 0x04	; 4
 3d0:	8c 62       	ori	r24, 0x2C	; 44
 3d2:	84 b9       	out	0x04, r24	; 4
	SPCR |= (1<<SPE)|(1<<MSTR)|(1<<SPR0);//prescaler 16
 3d4:	8c b5       	in	r24, 0x2c	; 44
 3d6:	81 65       	ori	r24, 0x51	; 81
 3d8:	8c bd       	out	0x2c, r24	; 44
 3da:	08 95       	ret

000003dc <spi_transmit>:
}


uint8_t spi_transmit(uint8_t data)
{
	SPDR = data;
 3dc:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
 3de:	0d b4       	in	r0, 0x2d	; 45
 3e0:	07 fe       	sbrs	r0, 7
 3e2:	fd cf       	rjmp	.-6      	; 0x3de <spi_transmit+0x2>
	
	return SPDR;
 3e4:	8e b5       	in	r24, 0x2e	; 46
}
 3e6:	08 95       	ret

000003e8 <fwrite>:
 3e8:	a0 e0       	ldi	r26, 0x00	; 0
 3ea:	b0 e0       	ldi	r27, 0x00	; 0
 3ec:	ea ef       	ldi	r30, 0xFA	; 250
 3ee:	f1 e0       	ldi	r31, 0x01	; 1
 3f0:	0c 94 2e 02 	jmp	0x45c	; 0x45c <__prologue_saves__+0xc>
 3f4:	5b 01       	movw	r10, r22
 3f6:	4a 01       	movw	r8, r20
 3f8:	79 01       	movw	r14, r18
 3fa:	d9 01       	movw	r26, r18
 3fc:	13 96       	adiw	r26, 0x03	; 3
 3fe:	2c 91       	ld	r18, X
 400:	21 ff       	sbrs	r18, 1
 402:	1d c0       	rjmp	.+58     	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
 404:	c0 e0       	ldi	r28, 0x00	; 0
 406:	d0 e0       	ldi	r29, 0x00	; 0
 408:	c8 15       	cp	r28, r8
 40a:	d9 05       	cpc	r29, r9
 40c:	d9 f0       	breq	.+54     	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
 40e:	8c 01       	movw	r16, r24
 410:	6c 01       	movw	r12, r24
 412:	ca 0c       	add	r12, r10
 414:	db 1c       	adc	r13, r11
 416:	c8 01       	movw	r24, r16
 418:	0c 15       	cp	r16, r12
 41a:	1d 05       	cpc	r17, r13
 41c:	71 f0       	breq	.+28     	; 0x43a <__EEPROM_REGION_LENGTH__+0x3a>
 41e:	0f 5f       	subi	r16, 0xFF	; 255
 420:	1f 4f       	sbci	r17, 0xFF	; 255
 422:	d7 01       	movw	r26, r14
 424:	18 96       	adiw	r26, 0x08	; 8
 426:	ed 91       	ld	r30, X+
 428:	fc 91       	ld	r31, X
 42a:	19 97       	sbiw	r26, 0x09	; 9
 42c:	b7 01       	movw	r22, r14
 42e:	dc 01       	movw	r26, r24
 430:	8c 91       	ld	r24, X
 432:	09 95       	icall
 434:	89 2b       	or	r24, r25
 436:	79 f3       	breq	.-34     	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
 438:	05 c0       	rjmp	.+10     	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
 43a:	21 96       	adiw	r28, 0x01	; 1
 43c:	e5 cf       	rjmp	.-54     	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
 43e:	80 e0       	ldi	r24, 0x00	; 0
 440:	90 e0       	ldi	r25, 0x00	; 0
 442:	01 c0       	rjmp	.+2      	; 0x446 <__EEPROM_REGION_LENGTH__+0x46>
 444:	ce 01       	movw	r24, r28
 446:	cd b7       	in	r28, 0x3d	; 61
 448:	de b7       	in	r29, 0x3e	; 62
 44a:	ec e0       	ldi	r30, 0x0C	; 12
 44c:	0c 94 4a 02 	jmp	0x494	; 0x494 <__epilogue_restores__+0xc>

00000450 <__prologue_saves__>:
 450:	2f 92       	push	r2
 452:	3f 92       	push	r3
 454:	4f 92       	push	r4
 456:	5f 92       	push	r5
 458:	6f 92       	push	r6
 45a:	7f 92       	push	r7
 45c:	8f 92       	push	r8
 45e:	9f 92       	push	r9
 460:	af 92       	push	r10
 462:	bf 92       	push	r11
 464:	cf 92       	push	r12
 466:	df 92       	push	r13
 468:	ef 92       	push	r14
 46a:	ff 92       	push	r15
 46c:	0f 93       	push	r16
 46e:	1f 93       	push	r17
 470:	cf 93       	push	r28
 472:	df 93       	push	r29
 474:	cd b7       	in	r28, 0x3d	; 61
 476:	de b7       	in	r29, 0x3e	; 62
 478:	ca 1b       	sub	r28, r26
 47a:	db 0b       	sbc	r29, r27
 47c:	0f b6       	in	r0, 0x3f	; 63
 47e:	f8 94       	cli
 480:	de bf       	out	0x3e, r29	; 62
 482:	0f be       	out	0x3f, r0	; 63
 484:	cd bf       	out	0x3d, r28	; 61
 486:	09 94       	ijmp

00000488 <__epilogue_restores__>:
 488:	2a 88       	ldd	r2, Y+18	; 0x12
 48a:	39 88       	ldd	r3, Y+17	; 0x11
 48c:	48 88       	ldd	r4, Y+16	; 0x10
 48e:	5f 84       	ldd	r5, Y+15	; 0x0f
 490:	6e 84       	ldd	r6, Y+14	; 0x0e
 492:	7d 84       	ldd	r7, Y+13	; 0x0d
 494:	8c 84       	ldd	r8, Y+12	; 0x0c
 496:	9b 84       	ldd	r9, Y+11	; 0x0b
 498:	aa 84       	ldd	r10, Y+10	; 0x0a
 49a:	b9 84       	ldd	r11, Y+9	; 0x09
 49c:	c8 84       	ldd	r12, Y+8	; 0x08
 49e:	df 80       	ldd	r13, Y+7	; 0x07
 4a0:	ee 80       	ldd	r14, Y+6	; 0x06
 4a2:	fd 80       	ldd	r15, Y+5	; 0x05
 4a4:	0c 81       	ldd	r16, Y+4	; 0x04
 4a6:	1b 81       	ldd	r17, Y+3	; 0x03
 4a8:	aa 81       	ldd	r26, Y+2	; 0x02
 4aa:	b9 81       	ldd	r27, Y+1	; 0x01
 4ac:	ce 0f       	add	r28, r30
 4ae:	d1 1d       	adc	r29, r1
 4b0:	0f b6       	in	r0, 0x3f	; 63
 4b2:	f8 94       	cli
 4b4:	de bf       	out	0x3e, r29	; 62
 4b6:	0f be       	out	0x3f, r0	; 63
 4b8:	cd bf       	out	0x3d, r28	; 61
 4ba:	ed 01       	movw	r28, r26
 4bc:	08 95       	ret

000004be <_exit>:
 4be:	f8 94       	cli

000004c0 <__stop_program>:
 4c0:	ff cf       	rjmp	.-2      	; 0x4c0 <__stop_program>
